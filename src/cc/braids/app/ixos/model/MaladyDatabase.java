package cc.braids.app.ixos.model;

import static cc.braids.util.UFunctions.*;

import java.io.Serializable;
import java.util.*;
import java.util.Map.Entry;

import cc.braids.app.ixos.Malady;
import cc.braids.app.ixos.model.FindingIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.CategoryIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.LikelihoodIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.MaladyIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.OnsetIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.PalliProvocationIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.QualityIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.RadiationIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.SeverityIlk;
import cc.braids.app.ixos.model.MaladyDatabaseEnums.TreatmentIlk;
import cc.braids.util.*;

@SuppressWarnings("unused")
public class MaladyDatabase implements Serializable
{
	/** Generated by Eclipse */
	private static final long serialVersionUID = -2451324678929156634L;

	Map<CategoryIlk, Set<Malady>> categories = new HashMap<>();
	Map<MaladyIlk, Malady> ilkToMalady = new HashMap<>();
	List<Malady> topLevelMaladiesCache;

	
	/**
	 * Two-argument form - convenicence for eight-argument form.
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk)
	{
		LikelihoodIlk likelihoodIlk= null;
		OnsetIlk onsetIlk= null;
		PalliProvocationIlk provocationPalliationIlk= null;
		QualityIlk qualityIlk= null;
		RadiationIlk radiationIlk= null;
		SeverityIlk severityIlk= null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}
	
	/**
	 * Three-argument form - convenicence for eight-argument form.
	 *
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk)
	{
		RadiationIlk radiationIlk = null;
		SeverityIlk severityIlk = null;
		OnsetIlk onsetIlk = null;
		PalliProvocationIlk provocationPalliationIlk = null;
		QualityIlk qualityIlk = null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}
	
	/**
	 * Four-argument form - convenicence for eight-argument form.
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk, OnsetIlk onsetIlk)
	{
		PalliProvocationIlk provocationPalliationIlk= null;
		QualityIlk qualityIlk= null;
		RadiationIlk radiationIlk= null;
		SeverityIlk severityIlk= null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}

	/**
	 * Five-argument form - convenicence for eight-argument form.
	 *
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk, OnsetIlk onsetIlk,
			PalliProvocationIlk provocationPalliationIlk)
	{
		QualityIlk qualityIlk= null;
		RadiationIlk radiationIlk= null;
		SeverityIlk severityIlk= null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}
	
	/**
	 * Six-argument form - convenicence for eight-argument form.
	 *
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk, OnsetIlk onsetIlk,
			PalliProvocationIlk provocationPalliationIlk,
			QualityIlk qualityIlk)
	{
		RadiationIlk radiationIlk = null;
		SeverityIlk severityIlk = null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}

	/**
	 * Seven-argument form - convenicence for eight-argument form.
	 *
	 * @see #addFinding(MaladyIlk,FindingIlk,LikelihoodIlk,OnsetIlk,PalliProvocationIlk,QualityIlk,RadiationIlk,SeverityIlk)
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk, OnsetIlk onsetIlk,
			PalliProvocationIlk provocationPalliationIlk,
			QualityIlk qualityIlk, RadiationIlk radiationIlk)
	{
		SeverityIlk severityIlk = null;
		addFinding(maladyIlk, findingIlk, likelihoodIlk, onsetIlk, provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);
	}

	/**
	 * Add a finding to the database.
	 *
	 * Full form with eight arguments.
	 */
	public void addFinding(MaladyIlk maladyIlk, FindingIlk findingIlk,
			LikelihoodIlk likelihoodIlk, OnsetIlk onsetIlk,
			PalliProvocationIlk provocationPalliationIlk,
			QualityIlk qualityIlk, RadiationIlk radiationIlk,
			SeverityIlk severityIlk)
	{
		Malady malady = getOrRegisterMalady(maladyIlk);
		Finding finding = new Finding(findingIlk, likelihoodIlk, onsetIlk,
				provocationPalliationIlk, qualityIlk, radiationIlk, severityIlk);

		malady.add(finding);
	}
	
	public void addTreatment(MaladyIlk maladyIlk, TreatmentIlk treatmentIlk) {
		Malady malady = getOrRegisterMalady(maladyIlk);
		malady.add(treatmentIlk);
	}
	

	/**
	 * Responsible for storing relationship between category ily and malady ilk.
	 */
	public void category(MaladyIlk maladyIlk, CategoryIlk category)
	{
		if (category == null) {
			throw new IllegalArgumentException("category must be neither null nor empty");
		}

		// Get an/or initialize the list of maladies for that category.
		Set<Malady> maladiesInCategory = categories.get(category);
		if (maladiesInCategory == null) {
			maladiesInCategory = new HashSet<>();
			categories.put(category, maladiesInCategory);
		}

		Malady malady = getOrRegisterMalady(maladyIlk);		
		maladiesInCategory.add(malady);
		malady.setCategory(category);
	}
	
	/**
	 * Mark the model's initialization data -- findings, maladies, treatments,
	 * and pertinent negatives -- as "complete". Set up all caches (which, by
	 * the way, will not change, even if you try to add more malady data).
	 */
	public void crystallize() {
		// Crystallize each malady. This flattens all the unions and
		// subtractions for the findings and treatments.  Add each
		// malady's findings to the union of allFindings.
		//

		// allFindings = new HashSet<>();
		for (Malady malady : ilkToMalady.values()) {
			malady.crystallize();
			// outmoded by enum FindingIlk: allFindings.addAll(malady.getFindings());
		}


		// Create the cache for top-level maladies (the ones that are
		// not in the FOR_INTERNAL_USE_ONLY category.
		//

		// MaladyIlk length gives us an *upper limit* for the array size.
		topLevelMaladiesCache = new ArrayList<>(MaladyIlk.values().length);

		for (Entry<CategoryIlk, Set<Malady>> entry : categories.entrySet()) {
			if (entry.getKey() != CategoryIlk.FOR_INTERNAL_USE_ONLY) {
				for (Malady mal : entry.getValue()) {
					topLevelMaladiesCache.add(mal);
				}
			}
		}

	}
	
	public Malady getMaladyByIlk(MaladyIlk string) {
		return ilkToMalady.get(string);
	}
	
	/**
	 * Fetch a malady by name.  If one does not exist, create it.
	 *
	 * @param model  storage for all Malady objects
	 * @param ilk  of malady to fetch/create; must not be null
	 * @return  the malady instance having that name
	 */
	Malady getOrRegisterMalady(MaladyIlk ilk) {
		assert ilk != null;

		Malady result;
		result = getMaladyByIlk(ilk);
		if (result == null) {
			result = new Malady(ilk);
			ilkToMalady.put(ilk, result);
		}

		// Make sure the malady has the same ilk as the registry believes it
		// to have.
		//
		assert ilk == result.getIlk();

		return result;
	}
	
	public List<Malady> getTopLevelMaladies() {
		return topLevelMaladiesCache;
	}
	
	/**
	 * Two-argument form.
	 *
	 * @see #negativeFinding(MaladyIlk,FindingIlk,LikelihoodIlk)
	 */
	public void negativeFinding(MaladyIlk maladyIlk,
			FindingIlk findingIlk)
	{
		LikelihoodIlk likelihoodIlk = null;
		negativeFinding(maladyIlk, findingIlk, likelihoodIlk);
	}
	
	public void negativeFinding(MaladyIlk maladyIlk,
			FindingIlk findingIlk, LikelihoodIlk likelihoodIlk)
	{
		Malady malady = getOrRegisterMalady(maladyIlk);
		NegatedFinding neg = new NegatedFinding(findingIlk, likelihoodIlk);
		malady.add(neg);
	}
	
	/**
	 * Two-argument form.
	 *
	 * @see addFindingUnion(MaladyIlk,MaladyIlk,LikelihoodIlk)
	 */
	public void unionFindings(MaladyIlk destinationMaladyIlk, MaladyIlk sourceMaladyIlk) {
		LikelihoodIlk likelihoodIlk = null;
		unionFindings(destinationMaladyIlk, sourceMaladyIlk, likelihoodIlk);
	}
	
	/**
	 * Instruct the database that this malady's findings are a superset of another's.
	 *
	 * Full three-argument form.
	 */
	public void unionFindings(MaladyIlk destinationMaladyIlk,
	        MaladyIlk sourceMaladyIlk, LikelihoodIlk likelihoodIlk)
	{
		Malady malady = getOrRegisterMalady(destinationMaladyIlk);
		Malady sourceMalady = getOrRegisterMalady(sourceMaladyIlk);

		FindingUnion funion = new FindingUnion(sourceMalady, likelihoodIlk);
		malady.add(funion);

		// TODO deferred 20150825 experiment with uniting negative findings as well...
	}
	
	public void unionFindingsAndTx(MaladyIlk destinationMaladyIlk, MaladyIlk sourceMaladyIlk)
	{
		unionFindings(destinationMaladyIlk, sourceMaladyIlk);
		unionTreatments(destinationMaladyIlk, sourceMaladyIlk);
	}

	public void unionTreatments(MaladyIlk destinationMaladyIlk, MaladyIlk sourceMaladyIlk)
	{
		Malady malady = getOrRegisterMalady(destinationMaladyIlk);
		Malady sourceMalady = getOrRegisterMalady(sourceMaladyIlk);
		malady.addTreatmentUnion(sourceMalady);
	}
	
	/**
	 * 
	 * @param outputVarWarnings  
	 */
	public void validate(List<String> outputVarWarnings) {
		// Post-crystallization validations:
		List<String> messages = new ArrayList<>();

		////////////////////////////////////////////////////////////////////////
		// Thank you, stupid Java type system, for making copy-paste so popular.

		String name = "categories Map";
		if (categories == null) messages.add(name + " is null");
		else if (categories.size() == 0) messages.add(name + " is empty");

		name = "ilkToMalady Map";
		if (ilkToMalady == null) messages.add(name + " is null");
		else if (ilkToMalady.size() == 0) messages.add(name + " is empty");

		name = "topLevelMaladiesCache";
		if (topLevelMaladiesCache == null) messages.add(name + " is null");
		else if (topLevelMaladiesCache.size() == 0) messages.add(name + " is empty");

		//
		////////////////////////////////////////////////////////////////////////

		if (outputVarWarnings != null) {

			// Make sure all enums are accounted for in this database.
			// Java guarantees that we only use real enums, but not
			// that we use all of them.
			//

			Set<MaladyIlk> usedMaladyIlks = ilkToMalady.keySet();

			Set<FindingIlk> usedFindingIlks = EnumSet.noneOf(FindingIlk.class);
			// We don't care about likelihoodIlks, because we store them as Floats.
			//Set<LikelihoodIlk> usedLikelihoodIlks = EnumSet.noneOf(LikelihoodIlk.class);
			Set<OnsetIlk> usedOnsetIlks = EnumSet.noneOf(OnsetIlk.class);
			Set<PalliProvocationIlk> usedPalliProvocationIlks = EnumSet.noneOf(PalliProvocationIlk.class);
			Set<QualityIlk> usedQualityIlks = EnumSet.noneOf(QualityIlk.class);
			Set<RadiationIlk> usedRadiationIlks = EnumSet.noneOf(RadiationIlk.class);
			Set<SeverityIlk> usedSeverityIlks = EnumSet.noneOf(SeverityIlk.class);
			Set<TreatmentIlk> usedTreatmentIlks = EnumSet.noneOf(TreatmentIlk.class);

			for (Malady mal : ilkToMalady.values()) {
				for (Finding finding : mal.getFindings()) {
					usedFindingIlks.add(finding.getIlk());
					
					//usedLikelihoodIlks.add(finding.getLikelihood());
					if (finding.getOnset() != null) usedOnsetIlks.add(finding.getOnset());
					if (finding.getProvocation() != null) usedPalliProvocationIlks.add(finding.getProvocation());
					if (finding.getQuality() != null) usedQualityIlks.add(finding.getQuality());
					if (finding.getRadiation() != null) usedRadiationIlks.add(finding.getRadiation());
					if (finding.getSeverity() != null) usedSeverityIlks.add(finding.getSeverity());
				}

				/*  commented out
				for (FindingUnion funion : mal.getFindingUnions()) {
					usedLikelihoodIlks.add(funion.getLikelihood());
				}
				
				for (NegatedFinding negfind : mal.getNegatedFindings()) {
					// We don't count the findings in negated findings, 
					// because they are not useful without a positive
					// finding in some other malady.
					
					usedLikelihoodIlks.add(negfind.getLikelihood());
				}
				*/
				
				usedTreatmentIlks.addAll(mal.getTreatments());

				// We skip treatment-unions because those are just other maladies.
			}

			outputVarWarnings.addAll(diff(usedMaladyIlks, EnumSet.allOf(MaladyIlk.class), "MaladyIlk enum type"));
			outputVarWarnings.addAll(diff(usedFindingIlks, EnumSet.allOf(FindingIlk.class), "FindingIlk enum type"));
			//outputVarWarnings.addAll(diff(usedLikelihoodIlks, EnumSet.allOf(LikelihoodIlk.class), usedLikelihoodIlks, "LikelihoodIlk enum type"));
			outputVarWarnings.addAll(diff(usedOnsetIlks, EnumSet.allOf(OnsetIlk.class), "OnsetIlk enum type"));
			outputVarWarnings.addAll(diff(usedPalliProvocationIlks, EnumSet.allOf(PalliProvocationIlk.class), "PalliProvocationIlk enum type"));
			outputVarWarnings.addAll(diff(usedQualityIlks, EnumSet.allOf(QualityIlk.class), "QualityIlk enum type"));
			outputVarWarnings.addAll(diff(usedRadiationIlks, EnumSet.allOf(RadiationIlk.class), "RadiationIlk enum type"));
			outputVarWarnings.addAll(diff(usedSeverityIlks, EnumSet.allOf(SeverityIlk.class), "SeverityIlk enum type"));
			outputVarWarnings.addAll(diff(usedTreatmentIlks, EnumSet.allOf(TreatmentIlk.class), "TreatmentIlk enum type"));

		}


		Set<Malady> maladiesWithCategories = new HashSet<>();

		// Make a set of maladies that are in a category (FOR_INTERNAL_USE_ONLY
		// does count for this purpose).
		//
		for (Set<Malady> malSet : categories.values()) {
			for (Malady choco : malSet) {
				maladiesWithCategories.add(choco);
			}		
		}

		for (Malady mal : ilkToMalady.values()) {
			CategoryIlk category = mal.getCategory();

			if (category == null) {
				//if (!maladiesWithCategories.contains(milk)) {
					messages.add(repr(mal) + " has no category.  ");
			}
			else if (category == CategoryIlk.FOR_INTERNAL_USE_ONLY) {
				continue;  // further tests are only concerned with maladies outside this category.
			}
			
			if (mal.getFindingsDeep().size() == 0) {
				messages.add(repr(mal) + " has no findings.");
			}

			if (mal.getTreatmentsDeep().size() == 0) {
				messages.add(repr(mal) + " has no treatments.");
			}
		}

		if (messages.size() > 0) {
			throw new AssertionError(String.join(" ", messages));
		}
	}
	
}
